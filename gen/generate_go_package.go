package gen

import (
	"bytes"
	"fmt"
	"go/types"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
)

var goFileTemplate = template.Must(template.New("goFile").Parse(`
// This file was auto-generated by Grime.

package {{.Name}}

import (
{{range .StandardImports -}}
	{{"\t"}}{{if ne .Name ""}}{{.Name}} {{end}}"{{.PkgPath}}"
{{end -}}
{{range .OtherImports -}}
	{{"\t"}}{{if ne .Name ""}}{{.Name}} {{end}}"{{.PkgPath}}"
{{end -}}
)

var Library = runtime.MustNewEmptyLibrary([]common.Symbol{
{{range .PkgPathSegments -}}
	{{"\t"}}common.Symbol("{{.}}"),
{{end -}}
}, []int{})

var Bindings = common.BindingSet{
	0: map[common.Symbol]common.Location{
	{{range .Funcs -}}
		{{"\t"}}common.Symbol("{{.QualifiedName}}"): &common.Variable{common.Function({{.InternalName}})},
	{{end -}}
	},
}

{{range .Funcs}}
func {{.InternalName}}(c common.Continuation, args ...common.Datum) (common.EvaluationResult, error) {
	{{if len .Params -}}
	{{if .Type.Variadic -}}
	valid := len(args) >= {{len .Params}} - 1
	{{else -}}
	valid := len(args) == {{len .Params}}
	{{end -}}
	{{range $i, $param := .Params -}}
	{{if $param.Variadic -}}
	var {{$param.Name}} []{{$param.QualifiedType}}
	{{else -}}
	var {{$param.Name}} {{$param.QualifiedType}}
	{{end -}}
	if valid {
		{{if $param.Variadic -}}
		for _, arg := range args[{{$i}}:] {
			{{if ne $param.CoercibleType "" -}}
			coerced := arg
			if coercible, ok := coerced.({{$param.CoercibleType}}); ok {
				coerced = {{$param.QualifiedType}}(coercible)
			}
			elem, ok := coerced.({{$param.QualifiedType}})
			{{else -}}
			elem, ok := arg.({{$param.QualifiedType}})
			{{end -}}
			valid = valid && ok
			{{$param.Name}} = append({{$param.Name}}, elem)
		}
	{{else -}}
		var ok bool
		{{if ne $param.CoercibleType "" -}}
		coerced := args[{{$i}}]
		if coercible, ok := coerced.({{$param.CoercibleType}}); ok {
			coerced = {{$param.QualifiedType}}(coercible)
		}
		{{$param.Name}}, ok = coerced.({{$param.QualifiedType}})
		{{else -}}
		{{$param.Name}}, ok = args[{{$i}}].({{$param.QualifiedType}})
		{{end -}}
		valid = valid && ok
	{{end -}}
	}
	{{end -}}
	if !valid {
		var argTypes []string
		for _, arg := range args {
			argTypes = append(argTypes, reflect.TypeOf(arg).String())
		}
		return common.ErrorC(fmt.Errorf("{{.QualifiedName}}: expected ({{.ParamTypes}}) got (%v)", strings.Join(argTypes, ", ")))
	}
	{{end -}}
	{{range $i, $_ := .Results}}{{if gt $i 0}}, {{end}}r{{$i}}{{end}}{{if gt (len .Results) 0}} := {{end}}{{.QualifiedName}}(
	{{range .Params -}}
		{{"\t"}}{{if .Variadic -}}
		{{.Name}}...,
		{{- else -}}
		{{.Name}},
		{{- end}}
	{{end -}}
	)
	return common.CallC(c, util.List({{range $i, $_ := .Results}}{{if gt $i 0}}, {{end}}r{{$i}}{{end}}))
}
{{end}}
`))

type goPackage struct {
	*packages.Package
	imports *goImportSet
	Funcs   []*goFunc
}

func newGoPackage(pkg *packages.Package) *goPackage {
	imports := newGoImportSet()
	imports.add("fmt")
	imports.add("reflect")
	imports.add("strings")
	imports.add("github.com/katsuya94/grime/common")
	imports.add("github.com/katsuya94/grime/runtime")
	imports.add("github.com/katsuya94/grime/util")
	imports.add(pkg.PkgPath)
	funcs := []*goFunc{}
	scope := pkg.Types.Scope()
	for _, name := range scope.Names() {
		f, ok := scope.Lookup(name).(*types.Func)
		if !ok || !f.Exported() {
			continue
		}
		if f.Type().(*types.Signature).Recv() != nil {
			fmt.Printf("skipping %v because of receiver\n", f)
			continue
		}
		funcs = append(funcs, newGoFunc(imports, f))
	}
	return &goPackage{pkg, imports, funcs}
}

func (pkg *goPackage) PkgPathSegments() []string {
	return strings.Split(pkg.PkgPath, "/")
}

func (pkg *goPackage) StandardImports() []*goImport {
	return pkg.imports.imports(true)
}

func (pkg *goPackage) OtherImports() []*goImport {
	return pkg.imports.imports(false)
}

type goImportSet struct {
	pkgPaths map[string]string
	names    map[string]string
}

func newGoImportSet() *goImportSet {
	return &goImportSet{map[string]string{}, map[string]string{}}
}

func (set *goImportSet) add(pkgPath string) {
	if pkgPath == "" {
		return
	}
	if _, ok := set.names[pkgPath]; ok {
		return
	}
	name := defaultPkgName(pkgPath)
	for {
		if _, ok := set.pkgPaths[name]; !ok {
			break
		}
		name = fmt.Sprintf("_%s", name)
	}
	set.pkgPaths[name] = pkgPath
	set.names[pkgPath] = name
}

func (set *goImportSet) get(pkgPath string) string {
	if pkgPath == "" {
		return ""
	}
	return set.names[pkgPath]
}

func (set *goImportSet) imports(standard bool) []*goImport {
	mapping := map[string]string{}
	for name, pkgPath := range set.pkgPaths {
		parts := strings.Split(pkgPath, "/")
		if (len(parts) == 1) == standard {
			if name == parts[len(parts)-1] {
				mapping[pkgPath] = ""
			} else {
				mapping[pkgPath] = name
			}
		}
	}
	pkgPaths := []string{}
	for pkgPath := range mapping {
		pkgPaths = append(pkgPaths, pkgPath)
	}
	sort.Strings(pkgPaths)
	imports := []*goImport{}
	for _, pkgPath := range pkgPaths {
		imports = append(imports, &goImport{
			Name:    mapping[pkgPath],
			PkgPath: pkgPath,
		})
	}
	return imports
}

type goImport struct {
	Name    string
	PkgPath string
}

type goFunc struct {
	*types.Func
	Params  []*goVar
	Results []struct{}
}

func newGoFunc(imports *goImportSet, f *types.Func) *goFunc {
	params := []*goVar{}
	signature := f.Type().(*types.Signature)
	for i := 0; i < signature.Params().Len(); i++ {
		variadic := signature.Variadic() && i == signature.Params().Len()-1
		params = append(params, newGoVar(imports, signature.Params().At(i), variadic))
	}
	return &goFunc{f, params, make([]struct{}, signature.Results().Len())}
}

func (f *goFunc) InternalName() string {
	internalName := f.Name()
	internalName = string(regexp.MustCompile("[^a-zA-Z0-9]").ReplaceAll([]byte(internalName), []byte{}))
	internalName = string(append([]rune{unicode.ToLower([]rune(internalName)[0])}, []rune(internalName)[1:]...))
	return internalName
}

func (f *goFunc) ParamTypes() string {
	var paramTypes []string
	for _, param := range f.Params {
		if param.Variadic {
			paramTypes = append(paramTypes, fmt.Sprintf("...%v", param.Type().(*types.Slice).Elem()))
		} else {
			paramTypes = append(paramTypes, param.Type().String())
		}
	}
	return strings.Join(paramTypes, ", ")
}

func (f *goFunc) QualifiedName() string {
	pkgPath, name := splitName(f.FullName())
	return fmt.Sprintf("%v.%v", defaultPkgName(pkgPath), name)
}

func defaultPkgName(pkgPath string) string {
	parts := strings.Split(pkgPath, "/")
	return parts[len(parts)-1]
}

type goVar struct {
	*types.Var
	QualifiedType string
	CoercibleType string
	Variadic      bool
}

func newGoVar(imports *goImportSet, v *types.Var, variadic bool) *goVar {
	t := v.Type()
	if variadic {
		t = t.(*types.Slice).Elem()
	}
	pkgPath, name := splitName(t.String())
	imports.add(pkgPath)
	qualifiedType := qualifiedName(imports.get(pkgPath), name)
	coercibleType := ""
	switch qualifiedType {
	case "string":
		coercibleType = "common.String"
	}
	return &goVar{v, qualifiedType, coercibleType, variadic}
}

func (v *goVar) Name() string {
	return fmt.Sprintf("_%s", v.Var.Name())
}

func splitName(name string) (string, string) {
	a := strings.Split(name, ".")
	if len(a) == 1 {
		return "", a[0]
	}
	return a[0], a[1]
}

func qualifiedName(pkgName string, name string) string {
	if pkgName == "" {
		return name
	}
	return fmt.Sprintf("%v.%v", pkgName, name)
}

func generateGoPackage(pattern string) (bool, error) {
	pkg, err := loadPackage(pattern)
	if err != nil {
		return false, err
	} else if pkg == nil {
		return false, nil
	}
	buf := &bytes.Buffer{}
	err = goFileTemplate.Execute(buf, newGoPackage(pkg))
	if err != nil {
		return false, err
	}
	err = parseCheckWrite(fmt.Sprintf("%v.go", pkg.Name), generatedPackagePath(pkg.PkgPath), buf.String())
	if err != nil {
		return false, err
	}
	return true, nil
}
