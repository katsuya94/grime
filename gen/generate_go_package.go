package gen

import (
	"bytes"
	"fmt"
	"go/types"
	"regexp"
	"sort"
	"strings"
	"text/template"
	"unicode"

	"golang.org/x/tools/go/packages"
)

var goFileTemplate = template.Must(template.New("goFile").Parse(`
// This file was auto-generated by Grime.

package {{.Name}}

import (
{{range .StandardImports -}}
	{{"\t"}}{{if ne .Name ""}}{{.Name}} {{end}}"{{.PkgPath}}"
{{end -}}
{{if ne (len .OtherImports) 0}}
{{range .OtherImports -}}
	{{"\t"}}{{if ne .Name ""}}{{.Name}} {{end}}"{{.PkgPath}}"
{{end -}}
{{end -}}
)

var Library *runtime.Library = runtime.MustNewEmptyLibrary([]common.Symbol{
{{range .PkgPathSegments -}}
	{{"\t"}}common.Symbol("{{.}}"),
{{end -}}
}, []int{})

var Bindings = common.BindingSet{
	0: map[common.Symbol]common.Location{
	{{range .Funcs -}}
		{{"\t"}}common.Symbol("{{.QualifiedName}}"): &common.Variable{common.Function({{.InternalName}})},
	{{end -}}
	},
}

{{range .Funcs}}
func {{.InternalName}}(c common.Continuation, args ...common.Datum) (common.EvaluationResult, error) {
	{{if len .Params -}}
	{{if .Type.Variadic -}}
	valid := len(args) >= {{len .Params}} - 1
	{{else -}}
	valid := len(args) == {{len .Params}}
	{{end -}}
	{{range $i, $param := .Params -}}
	{{if $param.Variadic -}}
	var {{$param.Name}} []{{$param.QualifiedType}}
	{{else -}}
	var {{$param.Name}} {{$param.QualifiedType}}
	{{end -}}
	if valid {
		{{if $param.Variadic -}}
		for _, arg := range args[{{$i}}:] {
			elem, ok := arg.({{$param.QualifiedType}})
			valid = valid && ok
			{{$param.Name}} = append({{$param.Name}}, elem)
		}
	{{else -}}
		var ok bool
		{{$param.Name}}, ok = args[{{$i}}].({{$param.QualifiedType}})
		valid = valid && ok
	{{end -}}
	}
	{{end -}}
	if !valid {
		var argTypes []string
		for _, arg := range args {
			argTypes = append(argTypes, reflect.TypeOf(arg).String())
		}
		return common.ErrorC(fmt.Errorf("{{.QualifiedName}}: expected ({{.ParamTypes}}) got (%v)", strings.Join(argTypes, ", ")))
	}
	{{end -}}
	{{.QualifiedName}}(
	{{range .Params -}}
		{{"\t"}}{{if .Variadic -}}
		{{.Name}}...,
		{{- else -}}
		{{.Name}},
		{{- end}}
	{{end -}}
	)
	return common.CallC(c, common.Void)
}
{{end}}
`))

type goPackage struct {
	*packages.Package
	imports goImportSet
	funcs   []*goFunc
}

func newGoPackage(pkg *packages.Package) *goPackage {
	goImportSet := newGoImportSet()
	goImportSet.add("fmt")
	goImportSet.add("reflect")
	goImportSet.add("strings")
	goImportSet.add("github.com/katsuya94/grime/common")
	goImportSet.add("github.com/katsuya94/grime/runtime")
	goImportSet.add(pkg.PkgPath)
	return &goPackage{pkg, goImportSet, nil}
}

func (pkg *goPackage) PkgPathSegments() []string {
	return strings.Split(pkg.PkgPath, "/")
}

func (pkg *goPackage) Funcs() []*goFunc {
	if pkg.funcs == nil {
		pkg.funcs = []*goFunc{}
		scope := pkg.Types.Scope()
		for _, name := range scope.Names() {
			f, ok := scope.Lookup(name).(*types.Func)
			if !ok || !f.Exported() {
				continue
			}
			if f.Type().(*types.Signature).Recv() != nil {
				fmt.Printf("skipping %v because of receiver\n", f)
				continue
			}
			pkg.funcs = append(pkg.funcs, newGoFunc(pkg, f))
		}
	}
	return pkg.funcs
}

func (pkg *goPackage) StandardImports() []*goImport {
	return pkg.imports.imports(true)
}

func (pkg *goPackage) OtherImports() []*goImport {
	return pkg.imports.imports(false)
}

type goImportSet map[string]string

func newGoImportSet() goImportSet {
	return goImportSet{}
}

func (set goImportSet) add(pkgPath string) {
	for _, p := range set {
		if p == pkgPath {
			return
		}
	}
	parts := strings.Split(pkgPath, "/")
	name := parts[len(parts)-1]
	for {
		if _, ok := set[name]; !ok {
			break
		}
		name = fmt.Sprintf("_%s", name)
	}
	set[name] = pkgPath
}

func (set goImportSet) imports(standard bool) []*goImport {
	mapping := map[string]string{}
	for name, pkgPath := range set {
		parts := strings.Split(pkgPath, "/")
		if (len(parts) == 1) == standard {
			if name == parts[len(parts)-1] {
				mapping[pkgPath] = ""
			} else {
				mapping[pkgPath] = name
			}
		}
	}
	pkgPaths := []string{}
	for pkgPath := range mapping {
		pkgPaths = append(pkgPaths, pkgPath)
	}
	sort.Strings(pkgPaths)
	imports := []*goImport{}
	for _, pkgPath := range pkgPaths {
		imports = append(imports, &goImport{
			Name:    mapping[pkgPath],
			PkgPath: pkgPath,
		})
	}
	return imports
}

type goImport struct {
	Name    string
	PkgPath string
}

type goFunc struct {
	*types.Func
	pkg    *goPackage
	params []*goVar
}

func newGoFunc(pkg *goPackage, f *types.Func) *goFunc {
	return &goFunc{f, pkg, nil}
}

func (f *goFunc) InternalName() string {
	internalName := f.Name()
	internalName = string(regexp.MustCompile("[^a-zA-Z0-9]").ReplaceAll([]byte(internalName), []byte{}))
	internalName = string(append([]rune{unicode.ToLower([]rune(internalName)[0])}, []rune(internalName)[1:]...))
	return internalName
}

func (f *goFunc) Params() []*goVar {
	if f.params == nil {
		f.params = []*goVar{}
		signature := f.Type().(*types.Signature)
		params := signature.Params()
		for i := 0; i < params.Len(); i++ {
			f.params = append(f.params, newGoVar(f.pkg, params.At(i)))

		}
		if signature.Variadic() {
			f.params[len(f.params)-1].Variadic = true
		}
	}
	return f.params
}

func (f *goFunc) ParamTypes() string {
	var paramTypes []string
	for _, param := range f.Params() {
		if param.Variadic {
			paramTypes = append(paramTypes, fmt.Sprintf("...%v", param.Type().(*types.Slice).Elem()))
		} else {
			paramTypes = append(paramTypes, param.Type().String())
		}
	}
	return strings.Join(paramTypes, ", ")
}

func (f *goFunc) QualifiedName() string {
	return QualifiedName(f.FullName())
}

type goVar struct {
	*types.Var
	pkg      *goPackage
	Variadic bool
}

func newGoVar(pkg *goPackage, v *types.Var) *goVar {
	pkg.imports.add()
	return &goVar{v, pkg, false}
}

func (v *goVar) QualifiedType() string {
	if v.Variadic {
		return QualifiedName(v.Type().(*types.Slice).Elem().String())
	}
	return QualifiedName(v.Type().String())
}

func QualifiedName(name string) string {
	a := strings.Split(name, ".")
	if len(a) == 1 {
		return a[0]
	}
	b := strings.Split(a[0], "/")
	return fmt.Sprintf("%v.%v", b[len(b)-1], a[1])
}

func generateGoPackage(pattern string) (bool, error) {
	pkg, err := loadPackage(pattern)
	if err != nil {
		return false, err
	} else if pkg == nil {
		return false, nil
	}
	buf := &bytes.Buffer{}
	err = goFileTemplate.Execute(buf, newGoPackage(pkg))
	if err != nil {
		return false, err
	}
	err = parseCheckWrite(fmt.Sprintf("%v.go", pkg.Name), generatedPackagePath(pkg.PkgPath), buf.String())
	if err != nil {
		return false, err
	}
	return true, nil
}
